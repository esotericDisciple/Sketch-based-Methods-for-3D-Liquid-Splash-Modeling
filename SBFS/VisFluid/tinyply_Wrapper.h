#ifndef __tinyply_WRAPPER_H__
#define __tinyply_WRAPPER_H__

#include <thread>
#include <chrono>
#include <vector>
#include <sstream>
#include <fstream>
#include <iostream>
#include <cstring>
#include <iterator>

#include "tinyply.h"
#include "CGAL_Wrapper.h"

struct float2 { float x, y; };
struct float3 { float x, y, z; };
struct double3 { double x, y, z; };
struct uint3 { uint32_t x, y, z; };
struct uint4 { uint32_t x, y, z, w; };

struct geometry
{
	std::vector<float3> vertices;
	std::vector<float3> normals;
	std::vector<float2> texcoords;
	std::vector<uint3> triangles;
};

void Write_PLY_Point_Set(const std::string & filename, const float *X, const float *VN, int number)
{
	geometry example;
	for (int i = 0; i < number; i++)
	{
		example.vertices.push_back( float3 { X[3 * i + 0], X[3 * i + 1], X[3 * i + 2] });
		example.normals.push_back(float3{ VN[3 * i + 0], VN[3 * i + 1], VN[3 * i + 2] });
	}


	/*std::filebuf fb_ascii;
	fb_ascii.open(filename + "-ascii.ply", std::ios::out);
	std::ostream outstream_ascii(&fb_ascii);
	if (outstream_ascii.fail()) throw std::runtime_error("failed to open " + filename);*/

	std::filebuf fb_binary;
	fb_binary.open(filename, std::ios::out | std::ios::binary);
	std::ostream outstream_binary(&fb_binary);
	if (outstream_binary.fail()) throw std::runtime_error("failed to open " + filename);

	PlyFile out_file;

	out_file.add_properties_to_element("vertex", { "x", "y", "z" },
		Type::FLOAT32, example.vertices.size(), reinterpret_cast<uint8_t*>(example.vertices.data()), Type::INVALID, 0);

	out_file.add_properties_to_element("vertex", { "nx", "ny", "nz" }, 
		Type::FLOAT32, example.normals.size(), reinterpret_cast<uint8_t*>(example.normals.data()), Type::INVALID, 0);

	out_file.get_comments().push_back("generated by tinyply 2.2");

	// Write an ASCII file
	//out_file.write(outstream_ascii, false);

	// Write a binary file
	out_file.write(outstream_binary, true /*binary file?*/);
}

void Write_PLY_Point_Set(const std::string & in_filename, const std::string & out_filename)
{
	// estimate the normal first
	std::vector<PointVectorPair> orientedPoints = CGAL_Run_Estimate_Normal(in_filename);

	geometry example;
	for (std::vector<PointVectorPair>::iterator it = orientedPoints.begin(); it != orientedPoints.end(); ++it)
	{
		example.vertices.push_back(float3{ (float)it->first[0], (float)it->first[1], (float)it->first[2] });
		example.normals.push_back(float3{ (float)it->second[0], (float)it->second[1], (float)it->second[2] });
	}

	std::filebuf fb_binary;
	fb_binary.open(out_filename, std::ios::out | std::ios::binary);
	std::ostream outstream_binary(&fb_binary);
	if (outstream_binary.fail()) throw std::runtime_error("failed to open " + out_filename);

	PlyFile out_file;

	out_file.add_properties_to_element("vertex", { "x", "y", "z" },
		Type::FLOAT32, example.vertices.size(), reinterpret_cast<uint8_t*>(example.vertices.data()), Type::INVALID, 0);

	out_file.add_properties_to_element("vertex", { "nx", "ny", "nz" },
		Type::FLOAT32, example.normals.size(), reinterpret_cast<uint8_t*>(example.normals.data()), Type::INVALID, 0);

	out_file.get_comments().push_back("generated by tinyply 2.2");

 	out_file.write(outstream_binary, true);
}

void Read_PLY_File(const std::string & filepath,  float * &X, int &number, int * &T,int &t_number)
{
	try
	{
		std::ifstream ss(filepath, std::ios::binary);
		if (ss.fail()) throw std::runtime_error("failed to open " + filepath);

		PlyFile file;
		file.parse_header(ss);

		/*std::cout << "........................................................................\n";
		for (auto c : file.get_comments()) std::cout << "Comment: " << c << std::endl;
		for (auto e : file.get_elements())
		{
			std::cout << "element - " << e.name << " (" << e.size << ")" << std::endl;
			for (auto p : e.properties) std::cout << "\tproperty - " << p.name << " (" << tinyply::PropertyTable[p.propertyType].str << ")" << std::endl;
		}
		std::cout << "........................................................................\n";*/

		// Tinyply treats parsed data as untyped byte buffers. See below for examples.
		std::shared_ptr<PlyData> vertices, normals, faces, texcoords;

		// The header information can be used to programmatically extract properties on elements
		// known to exist in the header prior to reading the data. For brevity of this sample, properties 
		// like vertex position are hard-coded: 
		try { vertices = file.request_properties_from_element("vertex", { "x", "y", "z" }); }
		catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

		/*try { normals = file.request_properties_from_element("vertex", { "nx", "ny", "nz" }); }
		catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

		try { texcoords = file.request_properties_from_element("vertex", { "u", "v" }); }
		catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }*/

		// Providing a list size hint (the last argument) is a 2x performance improvement. If you have 
		// arbitrary ply files, it is best to leave this 0. 
		try { faces = file.request_properties_from_element("face", { "vertex_indices" }, 3); }
		catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

		file.read(ss);

		/*if (vertices) std::cout << "\tRead " << vertices->count << " total vertices " << std::endl;
		if (normals) std::cout << "\tRead " << normals->count << " total vertex normals " << std::endl;
		if (texcoords) std::cout << "\tRead " << texcoords->count << " total vertex texcoords " << std::endl;
		if (faces) std::cout << "\tRead " << faces->count << " total faces (triangles) " << std::endl;*/

		// type casting to your own native types - Option A
		{
			//const size_t numVerticesBytes = vertices->buffer.size_bytes();
			//std::vector<float3> verts(vertices->count);
			//std::memcpy(verts.data(), vertices->buffer.get(), numVerticesBytes);

			const size_t numVerticesBytes = vertices->buffer.size_bytes();
			std::memcpy(X, vertices->buffer.get(), numVerticesBytes);
			
			const size_t numFacesBytes = faces->buffer.size_bytes();
			std::memcpy(T, faces->buffer.get(), numFacesBytes);

			number = vertices->count;
			t_number = faces->count;
		}

		// type casting to your own native types - Option B
		{
			std::vector<float3> verts_floats;
			std::vector<double3> verts_doubles;
			if (vertices->t == tinyply::Type::FLOAT32) { /* as floats ... */ }
			if (vertices->t == tinyply::Type::FLOAT64) { /* as doubles ... */ }
		}
	}
	catch (const std::exception & e)
	{
		std::cerr << "Caught tinyply exception: " << e.what() << std::endl;
	}
}

#endif